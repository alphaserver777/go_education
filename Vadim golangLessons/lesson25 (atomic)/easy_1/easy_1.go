package main

import (
	"fmt"
	"sync"
	"sync/atomic"
	"time"
)

/*
Объяснение кода:

1. var counter int64: Объявляем переменную counter типа int64, которую будем увеличивать.
2. Цикл for: Запускаем 100 горутин.
3. Атомарное увеличение счетчика: В каждой горутине выполняется цикл, в котором 1000 раз вызывается atomic.AddInt64(&counter, 1).
  •  atomic.AddInt64(&counter, 1): Атомарно добавляет 1 к значению переменной counter. Это означает, что операция будет выполнена целиком и не будет прервана другой горутиной.
4. wg.Wait(): Дожидаемся завершения всех горутин.
5. fmt.Println("Counter:", counter): Выводим финальное значение счетчика.
*/

func main() {
	// 1. Объявляем переменную counter типа int64 для хранения счетчика.
	//    - Используем int64, так как это 64-битное целое число, что позволяет хранить большие значения и
	//      гарантировать, что переполнение не произойдет.
	var counter int64

	// 2. Объявляем переменную wg типа sync.WaitGroup для синхронизации горутин.
	//    - sync.WaitGroup используется для того, чтобы дождаться завершения всех горутин перед завершением программы.
	var wg sync.WaitGroup

	// 3. Запускаем 100 горутин (параллельных потоков выполнения).
	for i := 0; i < 100; i++ {
		// 4. Увеличиваем счетчик WaitGroup на 1 для каждой горутины.
		//    - Это означает, что WaitGroup должна ожидать завершения еще одной горутины.
		wg.Add(1)

		// 5. Запускаем новую горутину, которая выполняет увеличение счетчика counter.
		go func() {
			// 6. Гарантируем вызов wg.Done() после завершения горутины.
			//    - wg.Done() уменьшает счетчик WaitGroup на 1, сигнализируя, что горутина завершила свою работу.
			defer wg.Done()

			// 7. Внутренний цикл выполняется 1000 раз.
			for j := 0; j < 1000; j++ {
				// 8. Атомарное увеличение счетчика counter на 1.
				//    - atomic.AddInt64 гарантирует, что операция добавления выполняется атомарно (неделимо),
				//      что предотвращает гонку данных при одновременном доступе к переменной из нескольких горутин.
				atomic.AddInt64(&counter, 1)
			}
		}()
	}

	// 9. Ожидаем завершения всех горутин.
	//    - wg.Wait() блокирует выполнение main-горутины до тех пор, пока счетчик WaitGroup не станет равным 0,
	//      что означает завершение всех горутин.
	wg.Wait()

	// 10. Выводим на консоль финальное значение счетчика.
	fmt.Println("Counter:", counter)

	// 11. Даём программе время на завершение, перед тем как она сама завершится
	time.Sleep(1 * time.Second)
}
